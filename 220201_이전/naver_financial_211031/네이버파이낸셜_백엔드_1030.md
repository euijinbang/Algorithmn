

###### 문제 설명

n x n 크기의 빈 격자와, 정수 jump가 주어집니다. 당신은 이 격자의 최 좌측 상단 칸부터 달팽이처럼 시계방향으로 회전하면서 1부터 n2 까지의 숫자를 차례대로 채우려고 합니다.
아래는 n = 5인 경우, 숫자를 채워나가는 방향을 그림으로 표현한 것입니다.

![스크린샷 2020-01-29 오후 12.05.38.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/ybm/68706aea-feb0-4cc9-944b-b496fd2de59e/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-01-29%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2012.05.38.png)

숫자를 채워나가는 규칙은 다음과 같습니다.

1. 최 좌측 상단 칸에 1을 채웁니다.

2. 시계방향으로 회전하면서 숫자가 채워지지 않은 `jump - 1` 개의 빈칸을 지나친 후, `jump` 번째로 만나는 빈칸에 다음 숫자를 적습니다.

   2-1. 이미 숫자가 채워진 칸은 세지 않고 그냥 지나칩니다.
   2-2. 만약 격자의 중앙 부분에 도착하여 더 이상 갈 곳이 없다면, 다시 최 좌측 상단의 칸으로 돌아가서 하던 작업을 반복합니다.

3. 모든 격자에 1부터 n2 까지의 숫자가 채워질 때까지 2번 작업을 반복합니다.

격자의 세로 좌표는 위에서부터 아래로 1부터 n이며, 가로 좌표는 좌측에서 우측으로 1부터 n입니다. 따라서, 시작하는 칸은 1행 1열이 됩니다. 격자의 크기를 나타내는 n과 숫자를 채워나가는 간격 jump가 매개변수로 주어집니다. 이때, 마지막 숫자가 들어가는 행과 열을 차례대로 배열에 담아서 return 하도록 solution 함수를 완성해주세요.

------

##### 제한 조건

- n은 2 이상 25 이하인 자연수입니다.
- jump는 1 이상 25 이하인 자연수입니다.

------

##### 입출력 예

| n    | jump | result  |
| ---- | ---- | ------- |
| `5`  | `3`  | `[5,2]` |
| `4`  | `1`  | `[3,2]` |
| `3`  | `10` | `[2,1]` |







###### 문제 설명

온라인으로 시험을 보는 프로그래밍 학원이 있습니다. 모든 시험 문제는 프로그램에 의해 자동으로 채점되며, 부분점수가 부여됩니다. 채점은 답안 제출과 동시에 실시간으로 이루어지며, 채점 로그가 시험 관리자에게 전달됩니다. 관리자는 시험이 모두 끝난 후 채점 로그를 통해 부정행위자로 의심되는 사람들을 찾아내려고 합니다. 이를 위해 다음과 같은 조건을 정했습니다.

```
1. 두 수험자가 푼 문제 수가 같다. 단, 푼 문제 수가 5 미만인 경우는 제외한다.
2. 두 수험자가 푼 문제의 번호가 모두 같다.
3. 두 수험자가 푼 문제의 점수가 모두 같다.
```

임의의 두 수험자가 위 3가지 조건에 모두 부합하는 경우, 두 수험자를 부정행위자로 의심합니다.

수험자의 수험번호, 문제 번호, 받은 점수를 나타내는 문자열 배열 logs가 매개변수로 주어집니다. 위 조건에 해당하는 모든 부정행위 의심자의 수험번호를 배열에 담아 사전 순으로 정렬하여 return 하도록 solution 함수를 완성해주세요. 단, 부정행위자로 의심되는 수험자가 없는 경우에는 문자열 "None"을 배열에 담아 return 해주세요.

------

##### 제한사항

- logs의 길이는 1 이상 5,000 이하입니다.
  - logs의 원소는 한 수험자가 한 문제를 풀었을 때 받은 점수를 나타냅니다.
  - logs의 원소는 "수험번호 문제번호 점수" 형식의 문자열입니다.
  - 수험번호는 길이가 4인 문자열이며 숫자로만 이루어져 있습니다.
  - 문제번호는 1 이상 100 이하인 자연수입니다.
  - 점수는 0 이상 100 이하인 정수입니다.
  - 문제를 풀지 않은 경우는 logs에 기록되지 않습니다.
- 한 수험자가 같은 문제에 대해 여러 번 답안을 제출할 수 있습니다. 단, 마지막 제출의 채점 결과가 최종 점수입니다.
  - 0점을 받는 답안 제출도 문제를 푼 것으로 칩니다.

------

##### 입출력 예

| logs                                                         | result                                     |
| ------------------------------------------------------------ | ------------------------------------------ |
| `["0001 3 95", "0001 5 90", "0001 5 100", "0002 3 95", "0001 7 80", "0001 8 80", "0001 10 90", "0002 10 90", "0002 7 80", "0002 8 80", "0002 5 100", "0003 99 90"]` | `["0001", "0002"]`                         |
| `["1901 1 100", "1901 2 100", "1901 4 100", "1901 7 100", "1901 8 100", "1902 2 100", "1902 1 100", "1902 7 100", "1902 4 100", "1902 8 100", "1903 8 100", "1903 7 100", "1903 4 100", "1903 2 100", "1903 1 100", "1101 1 95", "1101 2 100", "1101 4 100", "1101 7 100", "1101 9 100", "1102 1 95", "1102 2 100", "1102 4 100", "1102 7 100", "1102 9 100"]` | `["1101", "1102", "1901", "1902", "1903"]` |
| `["1901 10 50", "1909 10 50"]`                               | `["None"]`                                 |

------

##### 입출력 예 설명

입출력 예 #1

입력 로그는 다음과 같습니다.

```
0001 3 95
0001 5 90
0001 5 100
0002 3 95
0001 7 80
0001 8 80
0001 10 90
0002 10 90
0002 7 80
0002 8 80
0002 5 100
0003 99 90
```

0001번 수험자는 문제 3번을 95점, 5번을 100점(마지막 제출 기준), 7번을 80점, 8번을 80점, 10번을 90점 받았습니다. 0002번 수험자는 0001번 수험자와 완전히 같은 문제를 풀어 같은 점수를 받았으며, 두 수험자가 푼 문제 수는 5개입니다. 따라서 0001번 수험자와 0002번 수험자는 부정행위자로 의심됩니다. 따라서 수험번호 "0001"과 "0002"를 배열에 담아 사전 순으로 정렬한 후 return 합니다.

입출력 예 #2
입력 로그는 다음과 같습니다.

```
1901 1 100
1901 2 100
1901 4 100
1901 7 100
1901 8 100
1902 2 100
1902 1 100
1902 7 100
1902 4 100
1902 8 100
1903 8 100
1903 7 100
1903 4 100
1903 2 100
1903 1 100
1101 1 95
1101 2 100
1101 4 100
1101 7 100
1101 9 100
1102 1 95
1102 2 100
1102 4 100
1102 7 100
1102 9 100
```

1901번 수험자, 1902번 수험자, 1903번 수험자는 모두 같은 문제 5개를 풀고, 같은 점수를 받았습니다. 따라서 세 사람은 한 그룹의 부정행위자로 의심됩니다. 1101번 수험자와 1102번 수험자는 같은 문제 5개를 풀고, 모두 같은 점수를 받았습니다. 따라서 두 사람은 또 다른 한 그룹의 부정행위자로 의심됩니다. 따라서 수험번호 "1901", "1902", "1903", "1101", "1102"을 배열에 담아 사전 순으로 정렬한 후 return 합니다.

입출력 예 #3
부정행위자로 의심받는 사람이 없으므로 ["None"]을 return 합니다







###### 문제 설명

N `x` N 정사각형 격자에서 다음과 같은 룰을 가진 게임을 합니다.

1. `최 좌측 상단(0, 0)`에서 출발해서 `최 우측 하단(N - 1, N - 1)`에 도착하여야 합니다.

   1-1. `(a, b)` = `(행 번호, 열 번호)`입니다.

2. 인접한 칸들 중에서, 오른쪽 혹은 아래쪽 칸으로만 이동할 수 있습니다.

3. 격자의 바깥으로는 벗어날 수 없습니다.

4. 방문한 칸에 적힌 숫자만큼 점수를 획득합니다.

5. `0` 이 적힌 칸을 방문하면, 현재까지 획득한 점수에 `-1`을 곱할 수 있습니다. 즉, 부호를 바꿀 수 있습니다.

   5-1. 부호를 바꾸지 않고, 그대로 유지하여도 괜찮습니다.

6. `(N-1, N-1)`에 도착했을 때, 획득한 점수를 가능한 크게 하는 것이 게임의 목적입니다.

아래 그림은 5 `x` 5 크기의 격자에서 최대 점수를 획득하는 경로를 나타냅니다.

![p1.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/e42b67ab-0b00-4ea5-856f-02ca828c79a0/p1.png)

- (0, 0)에서 출발해서(4, 4)에 도착하여야 합니다.
- 격자에 `0`이 적힌 파란 칸에서는, 그 칸을 방문할 때까지 획득한 점수의 부호를 바꿀 수 있습니다.
- 처음 방문한 파란 칸(1, 2)까지 획득한 점수는 `1 - 7 - 2 = - 8`입니다. 여기서 부호를 바꾸기로 하면, 누적 점수는 `8`로 바뀝니다.
- 두 번째로 방문한 파란 칸(3, 3)까지 획득한 점수는 `8 + 6 - 1 = 13`입니다. 여기서 부호를 바꾸지 않기로 하면, 누적 점수는 그대로 `13`입니다.
- 최종 도착 칸(4, 4)까지 획득한 점수는 `13 + 4 + 1 = 18`입니다.

격자의 상태 board가 매개변수로 주어집니다. 위에 주어진 룰에 따라 게임을 진행한다고 했을 때, 얻을 수 있는 최대 점수를 return 하도록 solution 함수를 완성해주세요.

##### 제한사항

- board는 행의 길이와 열의 길이가 같은 2차원 정수형 배열입니다.
  - board의 행의 길이(=열의 길이)는 2 이상 1,000 이하입니다.
  - board의 모든 원소는 -10,000 이상 10,000 이하인 정수입니다.
    - 즉, 격자 칸의 숫자는 -10,000 이상 10,000 이하인 정수입니다.
    - board의 행의 길이를 N이라고 하면, `board[0][0]`과 `board[N-1][N-1]`에는 항상 `0`이 `아닌 값`이 저장되어 있습니다.

------

\##### 입출력 예

| board                                                        | result |
| ------------------------------------------------------------ | ------ |
| [[1, -7, -2, 1, -1],[2, 3, 0, -1, -2],[1, -1, 6, -1, -2],[-1, 1, -2, 0, 4],[-10, 5, -3, -1, 1]] | 18     |
| [[-10, 20, 30],[-10, 0, 10],[-20, 40, 1]]                    | 61     |

##### 입출력 예 설명

입출력 예 #1

문제 예시와 같습니다.

입출력 예 #2

![p2.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/7c6209cc-71a8-46f6-b9a6-d12d7f80216c/p2.png)

- (1, 1)에 방문했을 때, 획득한 누적 점수(-20)를 20으로 바꿉니다.
- 그러면 최종 도착 칸(2, 2)까지 획득할 수 있는 최대 점수는 `20 + 40 + 1 = 61` 입니다.

